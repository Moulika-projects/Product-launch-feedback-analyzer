# -*- coding: utf-8 -*-
"""app65

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13yKPqnUtuQdg6vT5FXIhsn9ksN2flocb
"""

import inspect

if not hasattr(inspect, "getargspec"):
    def getargspec(func):
        from inspect import getfullargspec
        spec = getfullargspec(func)
        from collections import namedtuple
        ArgSpec = namedtuple("ArgSpec", "args varargs keywords defaults")
        return ArgSpec(spec.args, spec.varargs, spec.varkw, spec.defaults)
    inspect.getargspec = getargspec
import pkgutil

if not hasattr(pkgutil, "ImpImporter"):  # If ImpImporter is missing, define it manually
    class ImpImporter:
        def _init_(self, *args, **kwargs):
            raise ImportError("ImpImporter is not available in Python 3.12+")

    pkgutil.ImpImporter = ImpImporter  # Inject into pkgutil module



import setuptools

try:
    import distutils
except ImportError:
    print("Warning: distutils is not available.")

# Fix for pipeline() in Python 3.12 (getargspec removed)

import streamlit as st
import torch
import spacy
from transformers import BertTokenizer, BertForSequenceClassification, pipeline

# Load model & tokenizer
model_path = "C:/Users/Asus/fine_tuned_bert_sentiment (4)/fine_tuned_bert_sentiment"
tokenizer = BertTokenizer.from_pretrained(model_path)
model = BertForSequenceClassification.from_pretrained(model_path)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)
model.eval()

# Load SpaCy for aspect extraction
nlp = spacy.load("en_core_web_sm")
aspect_sentiment_model = pipeline("sentiment-analysis")

# Overall sentiment
def predict_overall_sentiment(text):
    inputs = tokenizer(text, return_tensors="pt", truncation=True, padding=True, max_length=128).to(device)
    with torch.no_grad():
        outputs = model(**inputs)
    logits = outputs.logits
    pred = torch.argmax(logits, dim=1).item()
    label_map = {0: "Negative", 1: "Neutral", 2: "Positive"}
    return label_map[pred]

# Extract aspects
def extract_aspects(text):
    doc = nlp(text)
    aspects = {"Price": "Not Mentioned", "Quality": "Not Mentioned"}
    for token in doc:
        if token.head.text.lower() in ["price", "quality"]:
            aspect_type = "Price" if token.head.text.lower() == "price" else "Quality"
            aspects[aspect_type] = token.text
    return aspects

# Aspect-based sentiment + recommendations
def predict_aspect_sentiment(text):
    aspects = {"Price": "Not Mentioned", "Quality": "Not Mentioned"}
    recommendations = []

    doc = nlp(text)
    price_text = ""
    quality_text = ""

    for sent in doc.sents:
        if "price" in sent.text.lower():
            price_text = sent.text
        if "quality" in sent.text.lower():
            quality_text = sent.text

    # Analyze price
    if price_text:
        result = aspect_sentiment_model(price_text)
        label = result[0]["label"]
        if "NEGATIVE" in label:
            aspects["Price"] = "Negative"
            recommendations.append("Consider offering discounts or better value.")
        elif "POSITIVE" in label:
            aspects["Price"] = "Positive"
            recommendations.append("Maintain competitive pricing to retain positive feedback.")
        else:
            aspects["Price"] = "Neutral"

    # Analyze quality
    if quality_text:
        result = aspect_sentiment_model(quality_text)
        label = result[0]["label"]
        if "NEGATIVE" in label:
            aspects["Quality"] = "Negative"
            recommendations.append("Improve quality control and product durability.")
        elif "POSITIVE" in label:
            aspects["Quality"] = "Positive"
            recommendations.append("Keep delivering high-quality products.")
        else:
            aspects["Quality"] = "Neutral"

    return aspects, recommendations

# Streamlit UI
st.title("Product Review Sentiment Analyzer")

user_input = st.text_area("Enter a product review:", height=80)

if st.button("Analyze"):
    if user_input.strip() == "":
        st.warning("Please enter a review.")
    else:
        overall = predict_overall_sentiment(user_input)
        st.subheader("Overall Sentiment:")
        st.markdown(f"<span style='color:blue; font-size:24px'>{overall}</span>", unsafe_allow_html=True)

        aspect_sentiments, recs = predict_aspect_sentiment(user_input)

        st.subheader("Aspect-Based Sentiment:")
        color_map = {"Positive": "green", "Neutral": "orange", "Negative": "red", "Not Mentioned": "gray"}
        for aspect, sentiment in aspect_sentiments.items():
            color = color_map.get(sentiment, "black")
            st.markdown(f"<span style='color:{color}'><b>{aspect}:</b> {sentiment}</span>", unsafe_allow_html=True)

        if recs:
            st.subheader("Recommendations:")
            for r in recs:
                st.markdown(f"- {r}")